(* Copyright (c) Microsoft Corporation. All rights reserved.
   Licensed under the MIT License. *)

(** This module is a plugin for Intel's Edger8r to generate edge routines
    for Keystone Enclave SDK, based on Open Enclave's implementation of
    their plugin. *)

open Ast
open Plugin
open Printf
open Util

(** ----- Begin code borrowed and tweaked from {!CodeGen.ml}. ----- *)
let is_foreign_array (pt : parameter_type) =
  match pt with
  | PTVal _ -> false
  | PTPtr (t, a) -> ( match t with Foreign _ -> a.pa_isary | _ -> false )

(** Get the array declaration from a list of array dimensions. Empty
    [ns] indicates the corresponding declarator is a simple identifier.
    Element of value -1 means that user does not specify the dimension
    size. *)
let get_array_dims (ns : int list) =
  let get_dim n = if n = -1 then "[]" else sprintf "[%d]" n in
  String.concat "" (List.map get_dim ns)

let get_typed_declr_str (ty : atype) (declr : declarator) =
  let tystr = get_tystr ty in
  let dmstr = get_array_dims declr.array_dims in
  sprintf "%s %s%s" tystr declr.identifier dmstr

(** Check whether given parameter [pt] is [const] specified. *)
let is_const_ptr (pt : parameter_type) =
  let aty = get_param_atype pt in
  match pt with
  | PTVal _ -> false
  | PTPtr (_, pa) -> (
      if not pa.pa_rdonly then false
      else match aty with Foreign _ -> false | _ -> true )

(** Generate parameter [p] representation. *)
let gen_parm_str (p : pdecl) =
  let pt, (declr : declarator) = p in
  let aty = get_param_atype pt in
  let str = get_typed_declr_str aty declr in
  if is_const_ptr pt then "const " ^ str else str

(** [conv_array_to_ptr] is used to convert Array form into Pointer form.
    {[
      int array[10][20] => [count = 200] int* array
    ]}

    This function is called when generating proxy/bridge code and the
    marshalling structure. *)
let conv_array_to_ptr (pd : pdecl) : pdecl =
  let pt, declr = pd in
  let get_count_attr ilist =
    (* XXX: assume the size of each dimension will be > 0. *)
    ANumber (List.fold_left (fun acc i -> acc * i) 1 ilist)
  in
  match pt with
  | PTVal _ -> (pt, declr)
  | PTPtr (aty, pa) ->
      if is_array declr then
        let tmp_declr = {declr with array_dims= []} in
        let tmp_aty = Ptr aty in
        let tmp_cnt = get_count_attr declr.array_dims in
        let tmp_pa =
          {pa with pa_size= {empty_ptr_size with ps_count= Some tmp_cnt}}
        in
        (PTPtr (tmp_aty, tmp_pa), tmp_declr)
      else (pt, declr)

(** ----- End code borrowed and tweaked from {!CodeGen.ml} ----- *)

(* Helper to map and filter out None at the same time. *)
let filter_map f l =
  (* Would be [List.of_seq (Seq.filter_map f (List.to_seq l))] if we
     had 4.07 everywhere. *)
  List.map
    (function Some x -> x | None -> invalid_arg "None")
    (List.filter (function Some _ -> true | None -> false) (List.map f l))

(* Helper to flatten and map at the same time. *)
let flatten_map f l = List.flatten (List.map f l)

let is_in_ptr = function
  | PTVal _ -> false
  | PTPtr (_, a) -> a.pa_chkptr && a.pa_direction = PtrIn

let is_out_ptr = function
  | PTVal _ -> false
  | PTPtr (_, a) -> a.pa_chkptr && a.pa_direction = PtrOut

let is_inout_ptr = function
  | PTVal _ -> false
  | PTPtr (_, a) -> a.pa_chkptr && a.pa_direction = PtrInOut

let is_in_or_inout_ptr (p, _) = is_in_ptr p || is_inout_ptr p

let is_out_or_inout_ptr (p, _) = is_out_ptr p || is_inout_ptr p

let is_str_ptr = function PTVal _ -> false | PTPtr (_, a) -> a.pa_isstr

let is_wstr_ptr = function PTVal _ -> false | PTPtr (_, a) -> a.pa_iswstr

let is_str_or_wstr_ptr (p, _) = is_str_ptr p || is_wstr_ptr p

(* This tests if the member has a non-empty size attribute,
   implying that it should be marshalled. *)
let is_marshalled_ptr = function
  | PTPtr (_, attr) -> attr.pa_size <> empty_ptr_size
  | PTVal _ -> false

let gen_c_for level count body =
  if count = "1" then body
  else
    let i = sprintf "_i_%i" level in
    [ [sprintf "for (size_t %s = 0; %s < %s; %s++)" i i count i]
    ; ["{"]
    ; List.map (( ^ ) "    ") body
    ; ["}"] ]
    |> List.flatten

let gen_c_deref level i = if i = "1" then "->" else sprintf "[_i_%i]." level

(** [write_file] opens [filename] in the directory [dir] and emits a
    comment noting the file is auto generated followed by the
    [content], it then closes the file. *)
let write_file (content : string list) (filename : string) (dir : string) =
  let os =
    if dir = "." then open_out filename
    else open_out (dir ^ separator_str ^ filename)
  in
  fprintf os "%s"
    (String.concat "\n"
       ( [ "/*"
         ; " *  This file is auto generated by edger8r. DO NOT EDIT."
         ; " */" ]
       @ content )) ;
  close_out os

let get_type_expr ptype =
  (* Get the base type of the parameter. That is, yield its [atype],
     unless it is a pointer, in which case decompose and yield the
     [atype] the pointer points to. *)
  let param_atype =
    let a = get_param_atype ptype in
    match a with Ptr p -> p | _ -> a
  in
  let tystr = get_tystr param_atype in
  match ptype with
  | PTPtr (_, ptr_attr) when ptr_attr.pa_isptr -> sprintf "*(%s)0" tystr
  | _ -> tystr

(** For a list of args and current count, get the corresponding
   argstruct variable name. The prefix is usually, but not always,
   ["_args."].*)
let edge_get_argstruct prefix args count =
  match args with
  | [] -> prefix
  | hd :: _ -> prefix ^ hd ^ gen_c_deref (List.length args) count

let attr_value_to_string argstruct = function
  | None -> None
  | Some (ANumber n) -> Some (string_of_int n)
  | Some (AString s) -> Some (argstruct ^ s)

(** For a parameter, get its size expression. *)
let get_param_size (ptype, decl, argstruct) =
  let type_expr = get_type_expr ptype in
  let get_ptr_or_decl_size (p : ptr_size) =
    let size = attr_value_to_string argstruct p.ps_size
    and count = attr_value_to_string argstruct p.ps_count in
    match (size, count) with
    | Some s, None -> s
    | None, Some c -> sprintf "(%s * sizeof(%s))" c type_expr
    (* TODO: Check that this is an even multiple of the size of type. *)
    | Some s, Some c -> sprintf "(%s * %s)" s c
    | None, None ->
        sprintf "sizeof(%s%s)" type_expr (get_array_dims decl.array_dims)
  in
  match ptype with
  | PTPtr (_, ptr_attr) ->
      if ptr_attr.pa_isstr then
        Some (argstruct ^ decl.identifier ^ "_len * sizeof(char)")
      else if ptr_attr.pa_iswstr then
        Some (argstruct ^ decl.identifier ^ "_len * sizeof(wchar_t)")
      else if ptr_attr.pa_chkptr then
        Some (get_ptr_or_decl_size ptr_attr.pa_size)
      else None
  (* Values have no marshalling size. *)
  | _ -> None

let edge_get_param_size (ptype, decl, argstruct) =
  match get_param_size (ptype, decl, argstruct) with
  | Some size -> size
  | None -> failwithf "Error: No size for " ^ decl.identifier

(** For a parameter, get its count expression. *)
let get_param_count (ptype, decl, argstruct) =
  let type_expr = get_type_expr ptype in
  let get_ptr_or_decl_count (p : ptr_size) =
    let size = attr_value_to_string argstruct p.ps_size
    and count = attr_value_to_string argstruct p.ps_count in
    match (size, count) with
    (* TODO: Check that these are even multiples of the size of type. *)
    | Some s, None -> sprintf "(%s / sizeof(%s))" s type_expr
    | None, Some c -> c
    | Some s, Some c -> sprintf "((%s * %s) / sizeof(%s))" s c type_expr
    | None, None ->
        let dims = List.map string_of_int decl.array_dims in
        String.concat " * " dims
  in
  match ptype with
  | PTPtr (_, ptr_attr) ->
      (* The count of a string is its length. *)
      if ptr_attr.pa_isstr || ptr_attr.pa_iswstr then
        (* TODO: Double-check that this length includes the
           null-terminator. *)
        Some (argstruct ^ decl.identifier ^ "_len")
      else if ptr_attr.pa_chkptr then
        Some (get_ptr_or_decl_count ptr_attr.pa_size)
        (* TODO: Should be able to return [Some "1"] for plain
           pointers and values. *)
      else None
  | PTVal _ -> None

let edge_get_param_count (ptype, decl, argstruct) =
  match get_param_count (ptype, decl, argstruct) with
  | Some count -> count
  | None -> failwithf "Error: No count for " ^ decl.identifier

(** Generate the prototype for a given function. *)
let edge_gen_prototype (fd : func_decl) =
  let plist_str =
    let args = List.map gen_parm_str fd.plist in
    match args with
    | [] -> "void"
    | [arg] -> arg
    | _ -> "\n    " ^ String.concat ",\n    " args
  in
  sprintf "%s %s(%s)" (get_tystr fd.rtype) fd.fname plist_str

(** Generate the wrapper prototype for a given function. Optionally
    add an [edge_enclave_t*] first parameter. *)
let edge_gen_wrapper_prototype (fd : func_decl) =
  let plist_str =
    let args =
      [ ( match fd.rtype with
        | Void -> []
        | _ -> [get_tystr fd.rtype ^ "* _retval"] )
      ; List.map gen_parm_str fd.plist ]
      |> List.flatten
    in
    match args with
    | [arg] -> arg
    | _ -> "\n    " ^ String.concat ",\n    " args
  in
  sprintf "edge_result_t %s(%s)" fd.fname plist_str

(** Emit [struct], [union], or [enum]. *)
let emit_composite_type =
  let emit_struct (s : struct_def) =
    [ "typedef struct " ^ s.sname
    ; "{"
    ; String.concat "\n"
        (List.map
           (fun (ptype, decl) ->
             sprintf "    %s %s%s;"
               (get_tystr (get_param_atype ptype))
               decl.identifier
               (get_array_dims decl.array_dims) )
           s.smlist)
    ; "} " ^ s.sname ^ ";"
    ; "" ]
  in
  let emit_union (u : union_def) =
    [ "typedef union " ^ u.uname
    ; "{"
    ; String.concat "\n"
        (List.map
           (fun (atype, decl) ->
             sprintf "    %s %s%s;" (get_tystr atype) decl.identifier
               (get_array_dims decl.array_dims) )
           u.umlist)
    ; "} " ^ u.uname ^ ";"
    ; "" ]
  in
  let emit_enum (e : enum_def) =
    [ "typedef enum " ^ e.enname
    ; "{"
    ; String.concat ",\n"
        (List.map
           (fun (name, value) ->
             sprintf "    %s%s" name
               ( match value with
               | EnumVal (AString s) -> " = " ^ s
               | EnumVal (ANumber n) -> " = " ^ string_of_int n
               | EnumValNone -> "" ) )
           e.enbody)
    ; "} " ^ e.enname ^ ";"
    ; "" ]
  in
  function
  | StructDef s -> emit_struct s
  | UnionDef u -> emit_union u
  | EnumDef e -> emit_enum e

(** Generate a cast expression for a pointer argument. Pointer
    arguments need to be cast to their root type, since the marshalling
    struct has the root pointer. For example:
    {[
      int a[10][20]
    ]}
    needs to be cast to [int *].

    NOTE: Foreign arrays are marshalled as [void *], but foreign pointers
    are marshalled as-is. *)
let get_cast_to_mem_expr (ptype, decl) (parens : bool) =
  match ptype with
  | PTVal _ -> ""
  | PTPtr (t, _) ->
      let tystr = get_tystr t in
      if is_array decl then
        let s = tystr ^ "*" in
        if parens then sprintf "(%s)" s else s
      else if is_foreign_array ptype then
        let s = if parens then "(void*)" else "void*" in
        sprintf "/* foreign array of type %s */ %s" tystr s
      else if parens then sprintf "(%s)" tystr
      else tystr

(** Generate a cast expression to a specific pointer type. For example,
    [int*] needs to be cast to
    {[
      *(int ( * )[5][6])
    ]}. *)
let get_cast_from_mem_expr (ptype, decl) =
  match ptype with
  | PTVal _ -> ""
  | PTPtr (t, attr) ->
      if is_array decl then
        sprintf "*(%s(*)%s)" (get_tystr t) (get_array_dims decl.array_dims)
      else if is_foreign_array ptype then
        sprintf "/* foreign array */ *(%s*)" (get_tystr t)
      else if attr.pa_rdonly then
        (* for ptrs, only constness is removed; add it back *)
        sprintf "(const %s)" (get_tystr t)
      else ""

let edge_gen_call_user_function (fd : func_decl) =
  [ "/* Call user function. */"
  ; (match fd.rtype with Void -> "" | _ -> "pargs_out->_retval = ")
    ^ fd.fname ^ "("
  ; String.concat ",\n    "
      (List.map
         (fun (ptype, decl) ->
           let cast_expr = get_cast_from_mem_expr (ptype, decl) in
           sprintf "    %spargs_in->%s" cast_expr decl.identifier )
         fd.plist)
    ^ ");" ]

let warn_non_portable_types (fd : func_decl) =
  (* Check if any of the parameters or the return type has the given
     root type. *)
  let uses_type (t : atype) =
    t = fd.rtype || List.exists (fun (p, _) -> t = get_param_atype p) fd.plist
  in
  let print_portability_warning ty =
    printf
      "Warning: Function '%s': %s has different sizes on Windows and Linux. \
       This enclave cannot be built in Linux and then safely loaded in \
       Windows.\n"
      fd.fname ty
  in
  let print_portability_warning_with_recommendation ty recommendation =
    printf
      "Warning: Function '%s': %s has different sizes on Windows and Linux. \
       This enclave cannot be built in Linux and then safely loaded in \
       Windows. Consider using %s instead.\n"
      fd.fname ty recommendation
  in
  (* longs are represented as an Int type *)
  let long_t = Int {ia_signedness= Signed; ia_shortness= ILong} in
  let ulong_t = Int {ia_signedness= Unsigned; ia_shortness= ILong} in
  if uses_type WChar then print_portability_warning "wchar_t" ;
  if uses_type LDouble then print_portability_warning "long double" ;
  (* Handle long type *)
  if uses_type (Long Signed) || uses_type long_t then
    print_portability_warning_with_recommendation "long" "int64_t or int32_t" ;
  (* Handle unsigned long type *)
  if uses_type (Long Unsigned) || uses_type ulong_t then
    print_portability_warning_with_recommendation "unsigned long"
      "uint64_t or uint32_t"

let warn_signed_size_or_count_types (fd : func_decl) =
  let print_signedness_warning p =
    printf
      "Warning: Function '%s': Size or count parameter '%s' should not be \
       signed.\n"
      fd.fname p
  in
  (* Get the names of all size and count parameters for the function [fd]. *)
  let size_params =
    filter_map
      (fun (ptype, _) ->
        (* The size may be either a [count] or [size], and then
           either a number or string. We are interested in the
           strings, as they indicate named [size] or [count]
           parameters. *)
        let param_name {ps_size; ps_count} =
          match (ps_size, ps_count) with
          (* [s] is the name of the parameter as a string. *)
          | None, Some (AString s) | Some (AString s), None -> Some s
          (* TODO: Check for [Some (ANumber n)] that [n < 1] *)
          | _ -> None
        in
        (* Only variables that are pointers where [chkptr] is true may
           have size parameters. *)
        match ptype with
        | PTPtr (_, a) when a.pa_chkptr -> param_name a.pa_size
        | _ -> None )
      fd.plist
  in
  (* Print warnings for size parameters that are [Signed]. *)
  List.iter
    (fun (ptype, decl) ->
      let id = decl.identifier in
      if List.mem id size_params then
        match ptype with
        | PTVal (Long s | LLong s) when s = Signed ->
            print_signedness_warning id
        | PTVal (Int i) when i.ia_signedness = Signed ->
            print_signedness_warning id
        | _ -> () )
    fd.plist

let warn_size_and_count_params (fd : func_decl) =
  let print_size_and_count_warning {ps_size; ps_count} =
    match (ps_size, ps_count) with
    | Some (AString p), Some (AString q) ->
        failwithf
          "Function '%s': simultaneous 'size' and 'count' parameters '%s' and \
           '%s' are not supported by edger8r.\n"
          fd.fname p q
    | _ -> ()
  in
  List.iter
    (fun (ptype, _) ->
      match ptype with
      | PTPtr (_, ptr_attr) when ptr_attr.pa_chkptr ->
          print_size_and_count_warning ptr_attr.pa_size
      | _ -> () )
    fd.plist

(** Generate the Enclave code. *)
let gen_enclave_code (ec : enclave_content) (ep : edger8r_params) =
  (* Short aliases for the trusted and untrusted function
     declarations. *)
  let tfs = ec.tfunc_decls in
  let ufs = ec.ufunc_decls in
  (* Validate EDL features.
     NOTE: This validation has the side effects of printed warnings
     or failure with an error message. *)
  if ep.use_prefix then
    failwithf "--use_prefix option is not supported by edger8r." ;
  List.iter
    (fun f ->
      if f.tf_is_priv then
        failwithf
          "Function '%s': 'private' specifier is not supported by edger8r"
          f.tf_fdecl.fname ;
      if f.tf_is_switchless then
        failwithf
          "Function '%s': switchless annotation is not supported."
          f.tf_fdecl.fname )
    tfs ;
  List.iter
    (fun f ->
      ( if f.uf_fattr.fa_convention <> CC_NONE then
        let cconv_str = get_call_conv_str f.uf_fattr.fa_convention in
        printf
          "Warning: Function '%s': Calling convention '%s' for ocalls is not \
           supported by edger8r.\n"
          f.uf_fdecl.fname cconv_str ) ;
      if f.uf_fattr.fa_dllimport then
        failwithf "Function '%s': dllimport is not supported by edger8r."
          f.uf_fdecl.fname ;
      if f.uf_is_switchless then
        failwithf
          "Function '%s': switchless annotation is not supported."
          f.uf_fdecl.fname ;
      if f.uf_allow_list != [] then
        printf
          "Warning: Function '%s': Reentrant ocalls are not supported. \
           Allow list ignored.\n"
          f.uf_fdecl.fname)
    ufs ;
  (* Map warning functions over trusted and untrusted function
     declarations *)
  let ufuncs = List.map (fun f -> f.uf_fdecl) ufs in
  let tfuncs = List.map (fun f -> f.tf_fdecl) tfs in
  let funcs = List.append ufuncs tfuncs in
  List.iter
    (fun f ->
      warn_non_portable_types f ;
      warn_signed_size_or_count_types f ;
      warn_size_and_count_params f )
    funcs ;
  (* End EDL validation. *)
  (* Given [name], return the corresponding [StructDef], or [None]. *)
  let get_struct_by_name name =
    (* [ec.comp_defs] is a list of all composite types, but we're only
       interested in the structs, so we filter out the rest and unwrap
       them from [composite_type]. *)
    let structs =
      filter_map (function StructDef s -> Some s | _ -> None) ec.comp_defs
    in
    (* TODO: [List.find_opt] is better, but requires 4.05. *)
    if List.exists (fun s -> s.sname = name) structs then
      Some (List.find (fun s -> s.sname = name) structs)
    else None
  in
  (* We need to check [Ptr]s for [Foreign] or [Struct] types, then
     check those against the user's [Struct]s, and then check if any
     members should be deep copied. What we return is the list of
     members of the [Struct] which should be deep-copied, otherwise we
     return an empty list. *)
  let get_deepcopy_members (a : atype) =
    let should_deepcopy_a = function
      | Ptr (Struct n) | Ptr (Foreign n) -> get_struct_by_name n
      | _ -> None
    in
    (* Only enabled with --experimental! *)
    if ep.experimental then
      match should_deepcopy_a a with
      | Some s -> List.filter (fun (p, _) -> is_marshalled_ptr p) s.smlist
      | None -> []
    else []
  in
  let get_function_id (f : func_decl) =
    ec.enclave_name ^ "_fcn_id_" ^ f.fname
  in
  (* Emit IDs in enum for trusted functions. *)
  let emit_trusted_function_ids =
    [ "enum"
    ; "{"
    ; String.concat "\n"
        (List.mapi
           (fun i f -> sprintf "    %s = %d," (get_function_id f.tf_fdecl)
            (i+1))
           tfs)
    ; "    " ^ ec.enclave_name ^ "_fcn_id_trusted_call_id_max = EDGE_ENUM_MAX"
    ; "};" ]
  in
  (* Emit IDs in enum for untrusted functions. *)
  let emit_untrusted_function_ids =
    [ "enum"
    ; "{"
    ; String.concat "\n"
        (List.mapi
           (fun i f -> sprintf "    %s = %d," (get_function_id f.uf_fdecl)
	    (i+1))
           ufs)
    ; "    " ^ ec.enclave_name ^ "_fcn_id_untrusted_call_max = EDGE_ENUM_MAX"
    ; "};" ]
  in
  (* Generate [args.h] which contains [struct]s for ocalls *)
  let edge_gen_args_header =
    let edge_gen_marshal_struct (fd : func_decl) (errno : bool) =
      let gen_member_decl (ptype, decl) =
        let aty = get_param_atype ptype in
        let tystr = get_tystr aty in
        let tystr =
          if is_foreign_array ptype then
            sprintf "/* foreign array of type %s */ void*" tystr
          else tystr
        in
        let need_strlen =
          is_str_or_wstr_ptr (ptype, decl) && is_in_or_inout_ptr (ptype, decl)
        in
        let id = decl.identifier in
        [ [tystr ^ " " ^ id ^ ";"]
        ; (if need_strlen then [sprintf "size_t %s_len;" id] else []) ]
        |> List.flatten
      in
      let struct_name = fd.fname ^ "_args_t" in
      let retval_decl = {identifier= "_retval"; array_dims= []} in
      let members =
        [ ( if fd.rtype = Void then []
          else gen_member_decl (PTVal fd.rtype, retval_decl) )
        ; (if errno then ["int _ocall_errno;"] else [])
        ; flatten_map gen_member_decl (List.map conv_array_to_ptr fd.plist) ]
        |> List.flatten
      in
      [ "typedef struct _" ^ struct_name
      ; "{"
      ; "    " ^ String.concat "\n    " members
      ; "} " ^ struct_name ^ ";"
      ; "" ]
    in
    let edge_gen_user_includes (includes : string list) =
      if includes <> [] then List.map (sprintf "#include \"%s\"") includes
      else ["/* There were no user includes. */"]
    in
    let edge_gen_user_types (cts : composite_type list) =
      if cts <> [] then flatten_map emit_composite_type cts
      else ["/* There were no user defined types. */"; ""]
    in
    let edge_gen_ocall_marshal_structs =
      if ufs <> [] then
        flatten_map
          (fun uf -> edge_gen_marshal_struct uf.uf_fdecl uf.uf_propagate_errno)
          ufs
      else ["/* There were no ocalls. */"; ""]
    in
    let with_errno = List.exists (fun uf -> uf.uf_propagate_errno) ufs in
    let guard_macro =
      "EDGER8R_" ^ String.uppercase ec.enclave_name ^ "_ARGS_H"
    in
    [ "#ifndef " ^ guard_macro
    ; "#define " ^ guard_macro
    ; ""
    ; "#include <stdint.h>"
    ; "#include <stdlib.h> /* for wchar_t */"
    ; ""
    ; (let s = "#include <errno.h>" in
       if with_errno then s
       else
         sprintf "/* %s - Errno propagation not enabled so not included. */" s)
    ; ""
    ; "/**** User includes. ****/"
    ; String.concat "\n" (edge_gen_user_includes ec.include_list)
    ; ""
    ; "/**** User defined types in EDL. ****/"
    ; String.concat "\n" (edge_gen_user_types ec.comp_defs)
    ; "/**** OCALL marshalling structs. ****/"
    ; String.concat "\n" edge_gen_ocall_marshal_structs
    ; ""
    ; "/**** Untrusted function IDs. ****/"
    ; String.concat "\n" emit_untrusted_function_ids
    ; ""
    ; "#endif // " ^ guard_macro
    ; "" ]
  in
  (* Prepare [input_buffer]. *)
  let edge_prepare_input_buffer (fd : func_decl) (alloc_func : string) =
    let edge_compute_buffer_size buffer predicate plist =
      let rec gen_add_size args count (ptype, decl) =
        let argstruct = edge_get_argstruct "_args." args count in
        let size = edge_get_param_size (ptype, decl, argstruct) in
        let arg =
          match args with
          | [] -> decl.identifier
          | hd :: _ ->
              hd ^ gen_c_deref (List.length args) count ^ decl.identifier
        in
        gen_c_for (List.length args) count
          ( [ [ sprintf "if (%s)"
                  (String.concat " && " (List.rev (arg :: args))) ]
            ; [sprintf "    EDGE_ADD_SIZE(%s, %s);" buffer size]
            ; (let param_count = edge_get_param_count (ptype, decl, argstruct) in
               flatten_map
                 (gen_add_size (arg :: args) param_count)
                 (get_deepcopy_members (get_param_atype ptype))) ]
          |> List.flatten )
      in
      let params =
        flatten_map (gen_add_size [] "1") (List.filter predicate plist)
      in
      (* Note that the indentation for the first line is applied by the
         parent function. *)
      if params <> [] then String.concat "\n    " params
      else "/* There were no corresponding parameters. */"
    in
    let edge_compute_input_buffer_size =
      edge_compute_buffer_size "_input_buffer_size" is_in_or_inout_ptr
    in
    let edge_compute_output_buffer_size =
      edge_compute_buffer_size "_output_buffer_size" is_out_or_inout_ptr
    in
    let edge_serialize_buffer_inputs (plist : pdecl list) =
      let rec gen_serialize args count (ptype, decl) =
        let argstruct = edge_get_argstruct "_args." args count in
        let size = edge_get_param_size (ptype, decl, argstruct) in
        let arg =
          match args with
          | [] -> decl.identifier
          | hd :: _ ->
              hd ^ gen_c_deref (List.length args) count ^ decl.identifier
        in
        let tystr = get_cast_to_mem_expr (ptype, decl) false in
        (* These need to be in order and so done together. *)
        gen_c_for (List.length args) count
          ( [ (* NOTE: This makes the embedded check in the `EDGE_` macro superfluous. *)
              [ sprintf "if (%s)"
                  (String.concat " && " (List.rev (arg :: args))) ]
            ; [ sprintf "    EDGE_WRITE_%s_PARAM(%s, %s, %s);"
                  (if is_in_ptr ptype then "IN" else "IN_OUT")
                  arg size tystr ]
            ; (let param_count = edge_get_param_count (ptype, decl, argstruct) in
               flatten_map
                 (gen_serialize (arg :: args) param_count)
                 (get_deepcopy_members (get_param_atype ptype))) ]
          |> List.flatten )
      in
      let params =
        flatten_map (gen_serialize [] "1")
          (List.filter is_in_or_inout_ptr plist)
      in
      (* Note that the indentation for the first line is applied by the
         parent function. *)
      if params <> [] then String.concat "\n    " params
      else "/* There were no in nor in-out parameters. */"
    in
    [ "/* Compute input buffer size. Include in and in-out parameters. */"
    ; sprintf "EDGE_ADD_SIZE(_input_buffer_size, sizeof(%s_args_t));" fd.fname
    ; edge_compute_input_buffer_size fd.plist
    ; ""
    ; "/* Compute output buffer size. Include out and in-out parameters. */"
    ; sprintf "EDGE_ADD_SIZE(_output_buffer_size, sizeof(%s_args_t));" fd.fname
    ; edge_compute_output_buffer_size fd.plist
    ; ""
    ; "/* Allocate marshalling buffer. */"
    ; "_total_buffer_size = _input_buffer_size;"
    ; "EDGE_ADD_SIZE(_total_buffer_size, _output_buffer_size);"
    ; sprintf "_buffer = (uint8_t*)%s(_total_buffer_size);" alloc_func
    ; "_input_buffer = _buffer;"
    ; "_output_buffer = _buffer + _input_buffer_size;"
    ; "if (_buffer == NULL)"
    ; "{"
    ; "    _result = EDGE_OUT_OF_MEMORY;"
    ; "    goto done;"
    ; "}"
    ; ""
    ; "/* Serialize buffer inputs (in and in-out parameters). */"
    ; sprintf "_pargs_in = (%s_args_t*)_input_buffer;" fd.fname
    ; "EDGE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));"
    ; edge_serialize_buffer_inputs fd.plist
    ; ""
    ; "/* Copy args structure (now filled) to input buffer. */"
    ; "memcpy(_pargs_in, &_args, sizeof(*_pargs_in));" ]
  in
  let gen_times count body =
    (* The first two conditionals check for the multiplicative identity
       and prevent unnecessary expressions from being generated.
       Otherwise we multiply the sum of [body] by [count]. *)
    if count = "1" || body = [] then body
    else if List.length body = 1 && List.hd body = "1" then [count]
    else [count ^ " * (" ^ String.concat " + " body ^ ")"]
  in
  let rec gen_ptr_count args count (ptype, decl) =
    let id = decl.identifier in
    (* TODO: The use of [gen_c_deref] does not work here as we are not
       within a [gen_c_for] loop when producing the count. Therefore
       arrays of structs which use members for the count of another
       nested parameter are not yet supported. *)
    let argstruct = edge_get_argstruct "" args count in
    let arg =
      match args with
      | [] -> id
      | hd :: _ -> hd ^ gen_c_deref (List.length args) count ^ id
    in
    let param_count = edge_get_param_count (ptype, decl, argstruct) in
    let members = get_deepcopy_members (get_param_atype ptype) in
    if is_marshalled_ptr ptype then
      (* The base case is a marshalled pointer. We count 1 for every
         one of these, except for the top-level pointers as they are
         the original function arguments, and so do not need to be
         saved/restored.

         For a marshalled pointer, we then need to recurse. If there
         are no members to recurse on, then [members] is the empty
         list and the recursion is a no-op, leaving us back at the
         base case of counting 1. If there are members to recurse on,
         then we count 1 plus the current [param_count] times the
         number of members for each nested structure. *)
      (if args <> [] then ["1"] else [])
      @ gen_times param_count
          (flatten_map (gen_ptr_count (arg :: args) param_count) members)
    else []
  in
  let gen_ptr_array (plist : pdecl list) =
    let count =
      flatten_map (gen_ptr_count [] "1")
        (List.filter is_out_or_inout_ptr plist)
    in
    if count <> [] then
      (* TODO: Switch to malloc() to handle variable lengths. *)
      [ "size_t _ptrs_index = 0;"
      ; sprintf "void** _ptrs = malloc(sizeof(void*) * (%s));"
          (String.concat " + " count)
      ; "if (_ptrs == NULL)"
      ; "{"
      ; "    _result = EDGE_OUT_OF_MEMORY;"
      ; "    goto done;"
      ; "}" ]
    else ["/* No pointers to save for deep copy. */"]
  in
  let gen_reset_ptr_index (plist : pdecl list) =
    let count =
      flatten_map (gen_ptr_count [] "1")
        (List.filter is_out_or_inout_ptr plist)
    in
    if count <> [] then "_ptrs_index = 0; /* For deep copy. */"
    else "/* No pointers to restore for deep copy. */"
  in
  let gen_free_ptrs (plist : pdecl list) =
    let count =
      flatten_map (gen_ptr_count [] "1")
        (List.filter is_out_or_inout_ptr plist)
    in
    if count <> [] then ["if (_ptrs)"; "    free(_ptrs);"]
    else ["/* No `_ptrs` to free for deep copy. */"]
  in
  let edge_process_output_buffer (fd : func_decl) =
    let edge_serialize_buffer_outputs (plist : pdecl list) =
      let rec gen_serialize args count (ptype, decl) =
        let argstruct = edge_get_argstruct "_args." args count in
        let size = edge_get_param_size (ptype, decl, argstruct) in
        let arg =
          match args with
          | [] -> decl.identifier
          | hd :: _ ->
              hd ^ gen_c_deref (List.length args) count ^ decl.identifier
        in
        gen_c_for (List.length args) count
          ( [ ( if is_str_or_wstr_ptr (ptype, decl) then
                [ sprintf
                    "EDGE_CHECK_NULL_TERMINATOR%s(_output_buffer + \
                     _output_buffer_offset, _args.%s_len);"
                    (if is_wstr_ptr ptype then "_WIDE" else "")
                    arg ]
              else [] )
            ; (let s =
                 sprintf "EDGE_READ_%s_PARAM(%s, (size_t)(%s));"
                   (if is_out_ptr ptype then "OUT" else "IN_OUT")
                   arg size
               in
               match args with
               | [] -> [s]
               | _ ->
                   let tystr = get_cast_to_mem_expr (ptype, decl) true in
                   [ sprintf "if (%s)" (String.concat " && " (List.rev args))
                   ; "{"
                   ; "    /* Restore original pointer. */"
                   ; sprintf "    %s = %s_ptrs[_ptrs_index++];" arg tystr
                   ; "    " ^ s
                   ; "}" ])
            ; (let param_count = edge_get_param_count (ptype, decl, argstruct) in
               flatten_map
                 (gen_serialize (arg :: args) param_count)
                 (get_deepcopy_members (get_param_atype ptype))) ]
          |> List.flatten )
      in
      let params =
        flatten_map (gen_serialize [] "1")
          (List.filter is_out_or_inout_ptr plist)
      in
      if params <> [] then String.concat "\n    " params
      else "/* There were no out nor in-out parameters. */"
    in
    [ (* Verify that the ocall succeeded *)
      "/* Setup output arg struct pointer. */"
    ; sprintf "_pargs_out = (%s_args_t*)_output_buffer;" fd.fname
    ; "EDGE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));"
    ; ""
    ; "/* Unmarshal return value and out, in-out parameters. */"
    ; ( if fd.rtype <> Void then "*_retval = _pargs_out->_retval;"
      else "/* No return value. */" )
    ; gen_reset_ptr_index fd.plist
    ; edge_serialize_buffer_outputs fd.plist ]
  in
  let rec edge_gen_set_pointers args count setter (ptype, decl) =
    let argstruct = edge_get_argstruct "pargs_in->" args count in
    let size = edge_get_param_size (ptype, decl, argstruct) in
    let arg =
      match args with
      | [] -> decl.identifier
      | hd :: _ -> hd ^ gen_c_deref (List.length args) count ^ decl.identifier
    in
    let tystr = get_cast_to_mem_expr (ptype, decl) false in
    gen_c_for (List.length args) count
      ( [ (* NOTE: This makes the embedded check in the `EDGE_` macro superfluous. *)
          [ sprintf "if (pargs_in->%s)"
              (String.concat " && pargs_in->" (List.rev (arg :: args))) ]
        ; [ sprintf "    EDGE_%s_POINTER(%s, %s, %s);" (setter ptype) arg size
              tystr ]
        ; (let param_count = edge_get_param_count (ptype, decl, argstruct) in
           flatten_map
             (edge_gen_set_pointers (arg :: args) param_count setter)
             (get_deepcopy_members (get_param_atype ptype))) ]
      |> List.flatten )
  in
  let edge_gen_in_and_inout_setters (plist : pdecl list) =
    let params =
      flatten_map
        (edge_gen_set_pointers [] "1" (fun p ->
             (* TODO: Right now we assume all nested pointers should
                be [SET_IN_OUT], since nested pointers don't actually
                satisfy either [is_in_ptr] or [is_inout_ptr]
                predicates. *)
             if is_in_ptr p then "SET_IN" else "SET_IN_OUT" ))
        (List.filter is_in_or_inout_ptr plist)
    in
    "    "
    ^ String.concat "\n    "
        [ "/* Set in and in-out pointers. */"
        ; ( if params <> [] then String.concat "\n    " params
          else "/* There were no in nor in-out parameters. */" ) ]
  in
  let edge_gen_out_and_inout_setters (plist : pdecl list) =
    let params =
      flatten_map
        (edge_gen_set_pointers [] "1" (fun p ->
             (* TODO: Right now we assume all nested pointers should
                be [COPY_AND_SET_IN_OUT], since nested pointers don't
                actually satisfy either [is_out_ptr] or [is_inout_ptr]
                predicates. *)
             if is_out_ptr p then "SET_OUT" else "COPY_AND_SET_IN_OUT" ))
        (List.filter is_out_or_inout_ptr plist)
    in
    "    "
    ^ String.concat "\n    "
        [ "/* Set out and in-out pointers. */"
        ; "/* In-out parameters are copied to output buffer. */"
        ; ( if params <> [] then String.concat "\n    " params
          else "/* There were no out nor in-out parameters. */" ) ]
  in
  let gen_fill_marshal_struct (fd : func_decl) =
    (* Generate assignment argument to corresponding field in args. This
       is necessary for all arguments, not just copy-as-value, because
       they are used directly by later marshalling code. *)
    let gen_assignment (ptype, decl) =
      let arg = decl.identifier in
      [ [ sprintf "_args.%s = %s%s;" arg
            (get_cast_to_mem_expr (ptype, decl) true)
            arg ]
      ; (* for string parameter fill the len field *)
        ( if is_str_ptr ptype then
          [sprintf "_args.%s_len = (%s) ? (strlen(%s) + 1) : 0;" arg arg arg]
        else if is_wstr_ptr ptype then
          [sprintf "_args.%s_len = (%s) ? (wcslen(%s) + 1) : 0;" arg arg arg]
        else [] ) ]
      |> List.flatten
    in
    flatten_map gen_assignment fd.plist
    @
    let rec gen_save_ptrs args count (ptype, decl) =
      let id = decl.identifier in
      let argstruct = edge_get_argstruct "_args." args count in
      let arg =
        match args with
        | [] -> id
        | hd :: _ -> hd ^ gen_c_deref (List.length args) count ^ id
      in
      gen_c_for (List.length args) count
        ( [ ( if args <> [] then
              [sprintf "if (%s)" (String.concat " && " (List.rev args))]
            else [] )
          ; ( if args <> [] && is_marshalled_ptr ptype then
              ["    _ptrs[_ptrs_index++] = (void*)" ^ arg ^ ";"]
            else [] )
          ; (let param_count = edge_get_param_count (ptype, decl, argstruct) in
             flatten_map
               (gen_save_ptrs (arg :: args) param_count)
               (get_deepcopy_members (get_param_atype ptype))) ]
        |> List.flatten )
    in
    flatten_map (gen_save_ptrs [] "1")
      (List.filter is_out_or_inout_ptr fd.plist)
  in
  (* Generate enclave OCALL wrapper function. *)
  let edge_gen_enclave_ocall_wrapper (uf : untrusted_func) =
    let fd = uf.uf_fdecl in
    let allocate_buffer, call_function, free_buffer =
      if uf.uf_is_switchless then
        ( "edge_allocate_switchless_ocall_buffer"
        , "edge_switchless_call_host_function"
        , "edge_free_switchless_ocall_buffer" )
      else
        ( "malloc"
        , "ocall"
        , "free" )
    in
    [ edge_gen_wrapper_prototype fd
    ; "{"
    ; "    edge_result_t _result = EDGE_FAILURE;"
    ; ""
    ; "    /* Marshalling struct. */"
    ; sprintf "    %s_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;"
        fd.fname
    ; "    " ^ String.concat "\n    " (gen_ptr_array fd.plist)
    ; ""
    ; "    /* Marshalling buffer and sizes. */"
    ; "    size_t _input_buffer_size = 0;"
    ; "    size_t _output_buffer_size = 0;"
    ; "    size_t _total_buffer_size = 0;"
    ; "    uint8_t* _buffer = NULL;"
    ; "    uint8_t* _input_buffer = NULL;"
    ; "    uint8_t* _output_buffer = NULL;"
    ; "    size_t _input_buffer_offset = 0;"
    ; "    size_t _output_buffer_offset = 0;"
    ; ""
    ; "    /* Fill marshalling struct. */"
    ; "    memset(&_args, 0, sizeof(_args));"
    ; "    " ^ String.concat "\n    " (gen_fill_marshal_struct fd)
    ; ""
    ; "    "
      ^ String.concat "\n    " (edge_prepare_input_buffer fd allocate_buffer)
    ; ""
    ; "    /* Call host function. */"
    ; "    if ((_result = " ^ call_function ^ "("
    ; "             "
      ^ String.concat ",\n             "
          [ get_function_id fd
          ; "_input_buffer"
          ; "_input_buffer_size"
          ; "_output_buffer"
          ; "_output_buffer_size)) != EDGE_OK)" ]
    ; "        goto done;"
    ; ""
    ; "    " ^ String.concat "\n    " (edge_process_output_buffer fd)
    ; ""
    ; "    /* Retrieve propagated errno from OCALL. */"
    ; ( if uf.uf_propagate_errno then "    errno = _pargs_out->_ocall_errno;\n"
      else sprintf "    /* Errno propagation not enabled. */" )
    ; ""
    ; "    _result = EDGE_OK;"
    ; ""
    ; "done:"
    ; "    if (_buffer)"
    ; "        " ^ free_buffer ^ "(_buffer);"
    ; "    return _result;"
    ; "}"
    ; "" ]
  in
  (* Generate ocall function. *)
  let edge_gen_ocall_function (uf : untrusted_func) =
    let fd = uf.uf_fdecl in
    [ sprintf "void ocall_%s(void *buffer)" fd.fname
    ; "{"
    ; "    /* For now we assume the call struct is at the front of the shared"
    ; "     * buffer. This will have to change to allow nested calls. */"
    ; "    struct edge_call* edge_call = (struct edge_call*)buffer;"
    ; "    edge_result_t _result = EDGE_FAILURE;"
    ; "    uintptr_t call_args;"
    ; "    size_t args_len;"
    ; ""
    ; "    if (edge_call_args_ptr(edge_call, &call_args, &args_len) != 0) {"
    ; "        _result = EDGE_BAD_OFFSET;"
    ; "        goto done;"
    ; "    }"
    ; ""
    ; "    /* Prepare input buffer. */"
    ; "    void *input_buffer = (void *)call_args;"
    ; sprintf "    %s_args_t* pargs_in = (%s_args_t*)input_buffer;" fd.fname
        fd.fname
    ; sprintf "    %s_args_t* pargs_out = NULL;" fd.fname
    ; ""
    ; "    size_t input_buffer_offset = 0;"
    ; "    size_t output_buffer_offset = 0;"
    ; "    size_t input_buffer_size = 0;"
    ; "    size_t output_buffer_size = 0;"
    ; "    EDGE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));"
    ; sprintf "    EDGE_ADD_SIZE(output_buffer_offset, sizeof(%s_args_t));"
        fd.fname
    ; "    EDGE_ADD_SIZE(input_buffer_size, args_len);"
    ; ""
    ; (* Input buffer validation *)
      "    /* Make sure input buffer is valid. */"
    ; "    if (!input_buffer) {"
    ; "        _result = EDGE_BAD_PTR;"
    ; "        goto done;"
    ; "    }"
    ; ""
    ; (* Prepare in and in-out parameters *)
      edge_gen_in_and_inout_setters fd.plist
    ; ""
    ; (* Prepare output buffer *)
      "    /* Prepare output buffer. */"
    ; "    void *output_buffer = malloc(output_buffer_offset);"
    ; ""
    ; (* Output buffer validation *)
      "    /* Make sure output buffer is valid. */"
    ; "    if (!output_buffer) {"
    ; "        _result = EDGE_OUT_OF_MEMORY;"
    ; "        goto done;"
    ; "    }"
    ; ""
    ; (* Prepare out and in-out parameters. The in-out parameter is copied to output buffer. *)
      edge_gen_out_and_inout_setters fd.plist
    ; ""
    ; sprintf "    pargs_out = (%s_args_t*)output_buffer;" fd.fname
    ; ""
    ; (* Call the host function *)
      "    " ^ String.concat "\n    " (edge_gen_call_user_function fd)
    ; ""
    ; "    /* Propagate errno back to enclave. */"
    ; ( if uf.uf_propagate_errno then "    pargs_out->_ocall_errno = errno;"
      else "    /* Errno propagation not enabled. */" )
    ; ""
    ; "    /* This handles wrapping the data into an edge_data_t and"
    ; "       storing it in the shared region. */"
    ; "    if (edge_call_setup_wrapped_ret(edge_call, output_buffer,"
    ; "                                    output_buffer_offset)) {"
    ; "        _result = EDGE_BAD_PTR;"
    ; "    } else {"
    ; "        _result = EDGE_OK;"
    ; "    }"
    ; ""
    ; "done:"
    ; "    edge_call->return_data.call_status = _result;"
    ; "}"
    ; "" ]
  in
  (* Includes are emitted in [args.h]. Imported functions have already
     been brought into function lists. *)
  let gen_t_h =
    let edge_gen_tfunc_prototypes =
      if tfs <> [] then
        List.map (fun f -> sprintf "%s;" (edge_gen_prototype f.tf_fdecl)) tfs
      else ["/* There were no ecalls. */"]
    in
    let edge_gen_ufunc_wrapper_prototypes =
      if ufs <> [] then
        List.map
          (fun f -> sprintf "%s;" (edge_gen_wrapper_prototype f.uf_fdecl))
          ufs
      else ["/* There were no ocalls. */"]
    in
    let guard = "EDGER8R_" ^ String.uppercase ec.file_shortnm ^ "_T_H" in
    [ "#ifndef " ^ guard
    ; "#define " ^ guard
    ; ""
    ; "#include \"eapp_utils.h\""
    ; "#include \"edge_call.h\""
    ; "#include \"syscall.h\""
    ; ""
    ; "#include \"edger_macros.h\""
    ; ""
    ; sprintf "#include \"%s_args.h\"" ec.file_shortnm
    ; ""
    ; "EDGE_EXTERNC_BEGIN"
    ; ""
    ; "/**** OCALL prototypes. ****/"
    ; String.concat "\n\n" edge_gen_ufunc_wrapper_prototypes
    ; ""
    ; "EDGE_EXTERNC_END"
    ; ""
    ; "#endif // " ^ guard
    ; "" ]
  in
  let gen_t_c =
    let edge_gen_enclave_ocall_wrappers =
      if ufs <> [] then flatten_map edge_gen_enclave_ocall_wrapper ufs
      else ["/* There were no ocalls. */"]
    in
    [ sprintf "#include \"%s_t.h\"" ec.file_shortnm
    ; ""
    ; "#include <stdlib.h>"
    ; "#include <string.h>"
    ; "#include <wchar.h>"
    ; ""
    ; "EDGE_EXTERNC_BEGIN"
    ; ""
    ; "void edge_init(){"
    ; "  /* Nothing for now, will probably register buffers/callsites"
    ; "     later */"
    ; "}"
    ; ""
    ; "/**** OCALL function wrappers. ****/"
    ; ""
    ; String.concat "\n" edge_gen_enclave_ocall_wrappers
    ; "EDGE_EXTERNC_END"
    ; "" ]
  in
  let gen_u_h =
    let edge_gen_tfunc_wrapper_prototypes =
      if tfs <> [] then
        List.map (fun f -> edge_gen_wrapper_prototype f.tf_fdecl ^ ";") tfs
      else ["/* There were no ecalls. */"]
    in
    let edge_gen_ufunc_prototypes =
      if ufs <> [] then
        List.map (fun f -> edge_gen_prototype f.uf_fdecl ^ ";") ufs
      else ["/* There were no ocalls. */"]
    in
    let guard = "EDGER8R_" ^ String.uppercase ec.file_shortnm ^ "_U_H" in
    [ "#ifndef " ^ guard
    ; "#define " ^ guard
    ; ""
    ; "#include \"edger_macros.h\""
    ; ""
    ; sprintf "#include \"%s_args.h\"" ec.file_shortnm
    ; ""
    ; "EDGE_EXTERNC_BEGIN"
    ; ""
    ; "/**** OCALL prototypes. ****/"
    ; String.concat "\n\n" edge_gen_ufunc_prototypes
    ; ""
    ; "EDGE_EXTERNC_END"
    ; ""
    ; "#endif // " ^ guard
    ; "" ]
  in
  let gen_u_c =
    let edge_gen_ocall_functions =
      if ufs <> [] then flatten_map edge_gen_ocall_function ufs
      else ["/* There were no ocalls. */"]
    in
    let edge_gen_ocall_table =
      [ sprintf "edge_ocall_func_t __%s_ocall_function_table[] = {"
          ec.enclave_name
      ; "    "
        ^ String.concat "\n    "
            (List.map
               (fun f -> "(edge_ocall_func_t) ocall_" ^ f.uf_fdecl.fname ^ ",")
               ufs)
      ; "    NULL"
      ; "};" ]
    in
    [ sprintf "#include \"%s_u.h\"" ec.file_shortnm
    ; ""
    ; "#include \"edger_macros.h\""
    ; ""
    ; "#include <stdlib.h>"
    ; "#include <string.h>"
    ; "#include <wchar.h>"
    ; ""
    ; "EDGE_EXTERNC_BEGIN"
    ; ""
    ; "/**** OCALL functions. ****/"
    ; ""
    ; String.concat "\n" edge_gen_ocall_functions
    ; "/**** OCALL function table. ****/"
    ; ""
    ; String.concat "\n" edge_gen_ocall_table
    ; ""
    ; "EDGE_EXTERNC_END"
    ; "" ]
  in
  (* NOTE: The below code encapsulates all our file I/O. *)
  let args_h = ec.file_shortnm ^ "_args.h" in
  if ep.gen_trusted then (
    write_file edge_gen_args_header args_h ep.trusted_dir ;
    write_file gen_t_h (ec.file_shortnm ^ "_t.h") ep.trusted_dir ;
    if not ep.header_only then
      write_file gen_t_c (ec.file_shortnm ^ "_t.c") ep.trusted_dir ) ;
  if ep.gen_untrusted then (
    write_file edge_gen_args_header args_h ep.untrusted_dir ;
    write_file gen_u_h (ec.file_shortnm ^ "_u.h") ep.untrusted_dir ;
    if not ep.header_only then
      write_file gen_u_c (ec.file_shortnm ^ "_u.c") ep.untrusted_dir ) ;
  printf "Success.\n"

(** Install the plugin. *)
let _ =
  Printf.printf "Generating edge routines.\n" ;
  Plugin.instance.available <- true ;
  Plugin.instance.gen_edge_routines <- gen_enclave_code
